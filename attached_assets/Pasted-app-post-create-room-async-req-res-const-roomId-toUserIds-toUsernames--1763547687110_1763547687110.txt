app.post("/create-room", async (req, res) => {
  const {
    roomId,
    toUserIds,
    toUsernames,
    isVideo,
    fromUsername,
    groupName,
    checkOnly, // Flag to get token without triggering notifications
    // Keep backward compatibility
    roomName,
    participantName,
  } = req.body;

  console.log("came in create-room successfully");
  // Use new parameters or fall back to old ones for backward compatibility
  const finalRoomId = roomId || roomName;
  // const finalRoomId = "!pBwjTwVCSHvPMowYPr:ms2.beep.gov.pk";
  const finalParticipantName = fromUsername || participantName;

  console.log("Request data:", {
    roomId: finalRoomId,
    toUserIds,
    toUsernames,
    isVideo,
    fromUsername: finalParticipantName,
    groupName,
    checkOnly,
    roomName,
    participantName,
  });

  if (!finalRoomId || !finalParticipantName) {
    return res.status(400).json({
      error:
        "Missing required parameters: roomId and fromUsername are required",
    });
  }

  if (
    roomId &&
    (!toUserIds || !Array.isArray(toUserIds) || toUserIds.length === 0)
  ) {
    return res.status(400).json({
      error:
        "toUserIds array is required and must not be empty when using new call format",
    });
  }

  try {
    // Generate a room token for the caller
    const callerToken = new AccessToken(LIVEKIT_API_KEY, LIVEKIT_API_SECRET, {
      identity: finalParticipantName,
    });

    // Add grants before generating the JWT
    callerToken.addGrant({
      room: finalRoomId,
      roomJoin: true,
      canPublish: true,
      canSubscribe: true,
    });

    // Generate the JWT for caller
    const callerJwt = await callerToken.toJwt();
    console.log("Generated caller token grants:", callerToken.grants);

    // Generate a secure random key for E2EE if one doesn't exist
    if (!roomKeys.has(finalRoomId)) {
      const key = crypto.randomBytes(32).toString("base64");
      console.log("E2EE key:", key);
      roomKeys.set(finalRoomId, key);
    }

    const e2eeKey = roomKeys.get(finalRoomId);

    // If this is a new call format with recipients, send incoming call events
    if (roomId && toUserIds && toUserIds.length > 0) {
      if (checkOnly) {
        console.log(
          checkOnly=true, skipping notifications for room ${finalRoomId}
        );
      } else {
        console.log(Sending incoming call to ${toUserIds.length} users);
      }

      // Create participants list including caller and recipients
      const participants = [
        {
          userId: finalParticipantName, // Using fromUsername as userId for caller
          username: finalParticipantName,
          isOnline: true,
        },
        ...toUserIds.map((userId) => ({
          userId,
          username: toUsernames[userId] || userId,
          isOnline: SocketIO.isUserOnline(userId),
        })),
      ];

      // Only send notifications if checkOnly flag is not set
      if (!checkOnly) {
        // Send incoming call event to each recipient
        for (const toUserId of toUserIds) {
          const recipientDevices = SocketIO.onlineUsers.get(toUserId);
          console.log(
            recipientDevices for ${toUserId}:,
            recipientDevices ? recipientDevices.size : 0,
            "device(s)"
          );

          // Generate token for this specific recipient (needed for both online and offline users)
          const recipientToken = new AccessToken(
            LIVEKIT_API_KEY,
            LIVEKIT_API_SECRET,
            {
              identity: toUserId,
            }
          );

          recipientToken.addGrant({
            room: finalRoomId,
            roomJoin: true,
            canPublish: true,
            canSubscribe: true,
          });

          const recipientJwt = await recipientToken.toJwt();

          const callData = {
            roomId: finalRoomId,
            fromUserId: finalParticipantName,
            fromUsername: finalParticipantName,
            isVideo: isVideo || false,
            participants: participants,
            isGroup: toUserIds.length > 1,
            groupName: groupName || null,
            token: recipientJwt,
            serverUrl: LIVEKIT_URL,
            e2eeKey: e2eeKey,
            isDelayedCall: false, // This is a real-time call
          };

          // Always try to send to both connected devices and offline devices
          let hasConnectedDevices =
            recipientDevices && recipientDevices.size > 0;

          if (hasConnectedDevices) {
            console.log(
              Sending incoming call to online user: ${toUserId} on ${recipientDevices.size} device(s) with socket connections
            );
            // User has some devices online, send socket event to all their connected devices
            recipientDevices.forEach((deviceInfo, socketId) => {
              SocketIO.io.to(socketId).emit("incoming_call", callData);
            });
          }

          try {
            // Get device IDs that have socket connections
            const connectedDeviceIds = SocketIO.getConnectedDeviceIds(toUserId);
            console.log(
              User ${toUserId} has ${connectedDeviceIds.length} devices with socket connections:,
              connectedDeviceIds
            );

            // Always check for offline devices and send FCM to active devices without sockets
            // This handles cases where user has some devices online and some offline
            const fcmResult = await FCMService.notifyOfflineDevices(
              toUserId,
              callData,
              connectedDeviceIds
            );

            // Determine which devices need pending calls
            // FCM devices need pending calls because FCM only contains minimal data for security
            // When they click FCM and come online, they need full call data via socket
            const devicesWithSocketNotifications = [...connectedDeviceIds]; // Got full data immediately
            const devicesWithFCMNotifications = [
              ...fcmResult.notifiedDeviceIds,
            ]; // Got minimal FCM, need full data when online
            const devicesWithFailedNotifications =
              fcmResult.allActiveDeviceIds.filter(
                (deviceId) =>
                  !connectedDeviceIds.includes(deviceId) &&
                  !fcmResult.notifiedDeviceIds.includes(deviceId)
              ); // Failed FCM or no FCM token, need full data when online

            // Devices that need pending calls: FCM recipients + failed notification devices
            const pendingDeviceIds = [
              ...devicesWithFCMNotifications,
              ...devicesWithFailedNotifications,
            ];

            // Store pending call for devices that got FCM (need full data) or failed notifications
            if (pendingDeviceIds.length > 0) {
              storePendingCallForDevices(
                toUserId,
                callData,
                devicesWithSocketNotifications, // Only socket devices got full data
                pendingDeviceIds // FCM devices + failed devices need full data when online
              );
            }

            console.log(
              `Call notifications processed for user ${toUserId}: ` +
                `${connectedDeviceIds.length} socket (full data), ` +
                `${fcmResult.notifiedDeviceIds.length} FCM (minimal data), ` +
                `${devicesWithFailedNotifications.length} failed, ` +
                `${pendingDeviceIds.length} total pending (FCM + failed), ` +
                ${fcmResult.inactiveDeviceIds.length} inactive
            );
          } catch (error) {
            console.error(
              Failed to process notifications for ${toUserId}:,
              error
            );

            // Fallback: store pending call for completely offline user (old behavior)
            if (!hasConnectedDevices) {
              storePendingCallForDevices(toUserId, callData, [], ["unknown"]);
            }
          }
        }
      } else {
        console.log("Skipping notifications - checkOnly flag is set");
      }
    }

    // Return response for the caller
    res.json({
      token: callerJwt,
      serverUrl: LIVEKIT_URL,
      e2eeKey: e2eeKey,
      roomId: finalRoomId,
      participants: roomId
        ? toUserIds.map((userId) => ({
            userId,
            username: toUsernames[userId] || userId,
            isOnline: SocketIO.isUserOnline(userId),
          }))
        : undefined,
    });
  } catch (error) {
    console.error("Error generating token:", error);
    res.status(500).json({ error: "Failed to generate token" });
  }
});