this is how call_ended and decline events are setup in backend. would need to be triggered by frontend at appropriate time with appropriate data.

-> Call-ended event(fired by frontend when ending the call and there is only one remaining remote participant in the room)

socket.on(events.CALL_ENDED, (data) => {
        const { roomId, initiatorUserId, participantIds } = data;

        console.log(
          `[Socket] Call ended by ${initiatorUserId} for room ${roomId}, notifying ${participantIds.length} participants`
        );

        // Send call ended notification to all participants except the initiator
        participantIds.forEach((participantId) => {
          if (participantId !== initiatorUserId) {
            const participantDevices = SocketIO.onlineUsers.get(participantId);

            if (participantDevices && participantDevices.size > 0) {
              // Participant is online - send socket notification to all their devices
              const endedData = {
                roomId: roomId,
                endedBy: initiatorUserId,
                timestamp: new Date().toISOString(),
              };

              participantDevices.forEach((deviceInfo, socketId) => {
                SocketIO.io.to(socketId).emit("call_ended", endedData);
              });

              console.log(
                `[Socket] Call ended notification sent to ${participantDevices.size} device(s) of participant ${participantId}`
              );
            } else {
              // Participant is offline - check if they have a pending call and cancel it
              if (
                SocketIO.pendingCalls &&
                SocketIO.pendingCalls.has(participantId)
              ) {
                const pendingCall = SocketIO.pendingCalls.get(participantId);

                // Check if this pending call is for the same room that just ended
                if (pendingCall.callData.roomId === roomId) {
                  console.log(
                    `[Socket] Removing pending call for offline participant ${participantId} and sending cancellation notification`
                  );

                  // Remove from pending calls so they don't get the stale call when they come back online
                  SocketIO.pendingCalls.delete(participantId);

                  // Send call cancelled FCM notification to replace the incoming call notification
                  FCMService.sendCallCancelledNotification(
                    participantId,
                    pendingCall.callData
                  )
                    .then((success) => {
                      if (success) {
                        console.log(
                          `[Socket] Call cancellation notification sent to offline participant ${participantId}`
                        );
                      } else {
                        console.log(
                          `[Socket] Failed to send call cancellation notification to offline participant ${participantId}`
                        );
                      }
                    })
                    .catch((error) => {
                      console.error(
                        `[Socket] Error sending call cancellation notification to ${participantId}:`,
                        error
                      );
                    });
                } else {
                  console.log(
                    `[Socket] Participant ${participantId} has a pending call for different room (${pendingCall.callData.roomId}), not cancelling`
                  );
                }
              } else {
                console.log(
                  `[Socket] Participant ${participantId} is offline with no pending calls`
                );
              }
            }
          }
        });
      });

-> Call-decline event(fired by frontend when declining an incoming call)

    socket.on(events.CALL_DECLINED, (data) => {
        const { roomId, fromUserId, toUserId, isGroup } = data;

        console.log(
          `[Socket] Call declined by ${toUserId} for room ${roomId}, notifying caller and cancelling on other devices`
        );

        // 1. Send decline notification to caller (existing logic)
        if (!isGroup) {
          console.log(
            `[Socket] Sending call decline notification to ${fromUserId}`
          );

          // Find all sockets of the user who made the call (fromUserId)
          const callerDevices = SocketIO.onlineUsers.get(fromUserId);

          if (callerDevices && callerDevices.size > 0) {
            const declineData = {
              roomId: roomId,
              declinedBy: toUserId,
              fromUserId: fromUserId,
              timestamp: new Date().toISOString(),
            };

            // Send decline notification to all caller's devices
            callerDevices.forEach((deviceInfo, socketId) => {
              SocketIO.io.to(socketId).emit("call_declined", declineData);
            });

            console.log(
              `[Socket] Call decline notification sent to ${callerDevices.size} device(s) of ${fromUserId}`
            );
          } else {
            console.log(
              `[Socket] Caller ${fromUserId} is not online, cannot send decline notification`
            );
          }
        } else {
          console.log(`[Socket] Group call decline ignored for room ${roomId}`);
        }

        // 2. Cancel incoming call on all other devices of the declining user (NEW LOGIC)
        const decliningUserDevices = SocketIO.onlineUsers.get(toUserId);

        if (decliningUserDevices && decliningUserDevices.size > 1) {
          const cancelData = {
            roomId: roomId,
            declinedBy: toUserId,
            fromUserId: fromUserId,
            reason: "declined_on_another_device",
            timestamp: new Date().toISOString(),
          };

          // Send cancel notification to all OTHER devices of the declining user
          decliningUserDevices.forEach((deviceInfo, socketId) => {
            if (socketId !== socket.id) {
              SocketIO.io
                .to(socketId)
                .emit(events.CANCEL_INCOMING_CALL, cancelData);
            }
          });

          console.log(
            `[Socket] Incoming call cancelled on ${
              decliningUserDevices.size - 1
            } other device(s) of ${toUserId}`
          );
        }
